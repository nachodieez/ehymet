% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EHyClus.R
\name{EHyClus}
\alias{EHyClus}
\title{Clustering using Epigraph and Hypograph indices}
\usage{
EHyClus(
  curves,
  vars_combinations = 1,
  k = 30,
  n_clusters = 2,
  bs = "cr",
  clustering_methods = c("hierarch", "kmeans", "kkmeans", "spc"),
  indices = c("EI", "HI", "MEI", "MHI"),
  l_method_hierarch = c("single", "complete", "average", "centroid", "ward.D2"),
  l_dist_hierarch = c("euclidean", "manhattan"),
  l_dist_kmeans = c("euclidean", "mahalanobis"),
  l_kernel = c("rbfdot", "polydot"),
  grid,
  true_labels = NULL,
  verbose = FALSE,
  n_cores = 1
)
}
\arguments{
\item{curves}{Dataset containing the curves to apply a clustering algorithm.
The functional dataset can be one dimensional (\eqn{n \times p}) where \eqn{n} is the number of
curves and \code{p} the number of time points, or multidimensional (\eqn{n \times p \times q}) where \eqn{q}
represents the number of dimensions in the data}

\item{vars_combinations}{\code{integer} or \code{list}.
If \code{integer}, the method will automatically determine the best combinations
of variables. As many combinations will be selected as the value of the variable.
If \code{list},  each element of the list should be an atomic \code{vector} of strings with the
names of the variables. Combinations with non-valid variable names will be discarded.
If the list is non-named, the names of the variables are set to
vars1, ..., varsk, where k is the number of elements in \code{vars_combinations}.
Default to an \code{integer} with value \code{1}, i.e. it only uses the theoretically
best combination.}

\item{k}{Number of basis functions for the B-splines. If equals to \code{0}, the number
of basis functions will be automatically selected.}

\item{n_clusters}{Number of clusters to generate.}

\item{bs}{A two letter character string indicating the (penalized) smoothing
basis to use. See \code{\link{smooth.terms}}.}

\item{clustering_methods}{character vector specifying at least one of the following
clustering methods to be computed: "hierarch", "kmeans", "kkmeans" or "spc".}

\item{indices}{Names of the indices that need to be generated. They should be
one or more between "EI", "HI", "MEI" and "MHI". Depending on the dimension on the data,
its one-dimensional version or multi-dimensional version is computed.}

\item{l_method_hierarch}{\code{list} of clustering methods for hierarchical
clustering.}

\item{l_dist_hierarch}{\code{list} of distances for hierarchical clustering.}

\item{l_dist_kmeans}{\code{list} of distances for kmeans clustering.}

\item{l_kernel}{\code{list} of kernels for kkmeans or spc.}

\item{grid}{Atomic vector of type numeric with two elements: the lower limit and the upper
limit of the evaluation grid. If not provided, it will be selected automatically.}

\item{true_labels}{Numeric vector of true labels for validation. If provided,
more metrics are computed in the final result.}

\item{verbose}{If \code{TRUE}, the function will print logs for about the execution of
some clustering methods. Defaults to \code{FALSE}.}

\item{n_cores}{Number of cores to do parallel computation. 1 by default,
which mean no parallel execution. Must be an integer number greater than 1.}
}
\value{
A \code{list} containing the clustering partition for each method and indexes
combination and, if \code{true_labels} is provided a data frame containing the time elapsed for obtaining a
clustering partition of the indexes dataset for each methodology.
}
\description{
It creates a multivariate dataset containing
the epigraph, hypograph and/or its modified versions on the curves and derivatives
and then perform hierarchical clustering, kmeans, kernel kmeans, and spectral clustering
}
\examples{
vars_combinations <- list(c("dtaEI", "dtaMEI"), c("dtaHI", "dtaMHI"))
curves <- sim_model_ex1(n = 10)
EHyClus(curves, vars_combinations = vars_combinations)

}
